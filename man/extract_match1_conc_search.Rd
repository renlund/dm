% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/conc_search.R
\name{extract_match1_conc_search}
\alias{extract_match1_conc_search}
\title{first match from \code{pattern_conc_search}}
\usage{
extract_match1_conc_search(
  x,
  s,
  code.sep = " ",
  reduce = FALSE,
  s.fixed = FALSE
)
}
\arguments{
\item{x}{(concatenated) search string}

\item{s}{string to match initial part of code}

\item{code.sep}{the string that servers as separator in the concatenation}

\item{reduce}{if \code{FALSE}, always return string of same length as x}

\item{s.fixed}{set to \code{TRUE} if 's' was created by
\code{pattern_conc_search}}
}
\description{
use \code{pattern_conc_search} but also extract the match from within the
concatenation. Note to self: the use of \code{pattern_conc_search} is
superfluous within this function as it applies searches to the string which
is split at the \code{code.sep}, but makes it easier to use search terms
defined as variables
}
\examples{
x <- c("ABC", "", "FFF XXX", "GGG  ABC FOO",
       "BAR  ABC", "FOO BAR ABB", " ", ";")
s.term = c("AB(C|B)", "X")
## extract only the (first) matches
extract_match1_conc_search(x, s = s.term, reduce = TRUE)
## extract but do not reduce:
data.frame(x = x,
           extr.m1 = extract_match1_conc_search(x, s = s.term,
                                                reduce = FALSE))
## same example, different separator:
y <- gsub(pattern = " ", replacement = ";", x)
data.frame(y = y,
           extr = extract_match1_conc_search(y, s = s.term,
                                             code.sep = ";", reduce = FALSE))
}
